// Утилита для парсинга уязвимостей из логов Shannon

export interface ParsedVulnerability {
  type: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  location?: string;
}

/**
 * Парсит найденные уязвимости из логов
 * Упрощенный вариант - ищет простые паттерны
 */
export function parseVulnerabilitiesFromLogs(logs: Array<{ message: string; level: string }>): ParsedVulnerability[] {
  const vulnerabilities: ParsedVulnerability[] = [];
  const seen = new Set<string>();

  for (const log of logs) {
    const message = log.message.toLowerCase();

    // Поиск критических уязвимостей
    if ((message.includes('rate limiting') || message.includes('rate limit')) && !seen.has('rate-limiting')) {
      vulnerabilities.push({
        type: 'Rate Limiting',
        severity: 'critical',
        title: 'Отсутствие ограничения скорости запросов',
        location: 'Эндпоинт аутентификации',
      });
      seen.add('rate-limiting');
    }

    if ((message.includes('sql injection') || message.includes('sql-injection')) && !seen.has('sql-injection')) {
      vulnerabilities.push({
        type: 'SQL Injection',
        severity: 'high',
        title: 'Уязвимость SQL инъекции',
      });
      seen.add('sql-injection');
    }

    if ((message.includes('xss') || message.includes('cross-site scripting')) && !seen.has('xss')) {
      vulnerabilities.push({
        type: 'XSS',
        severity: 'high',
        title: 'Уязвимость межсайтового скриптинга (XSS)',
      });
      seen.add('xss');
    }

    if ((message.includes('csrf') || message.includes('cross-site request forgery')) && !seen.has('csrf')) {
      vulnerabilities.push({
        type: 'CSRF',
        severity: 'high',
        title: 'Уязвимость CSRF',
      });
      seen.add('csrf');
    }

    if ((message.includes('ssrf') || message.includes('server-side request forgery')) && !seen.has('ssrf')) {
      vulnerabilities.push({
        type: 'SSRF',
        severity: 'high',
        title: 'Уязвимость SSRF',
      });
      seen.add('ssrf');
    }

    if ((message.includes('auth') && message.includes('bypass')) && !seen.has('auth-bypass')) {
      vulnerabilities.push({
        type: 'Authentication Bypass',
        severity: 'critical',
        title: 'Обход аутентификации',
      });
      seen.add('auth-bypass');
    }

    if ((message.includes('path traversal') || message.includes('directory traversal')) && !seen.has('path-traversal')) {
      vulnerabilities.push({
        type: 'Path Traversal',
        severity: 'high',
        title: 'Уязвимость обхода пути',
      });
      seen.add('path-traversal');
    }

    // Поиск в логах с ошибками (error/warn)
    if (log.level === 'error' || log.level === 'warn') {
      if (message.includes('vulnerability') || message.includes('уязвимость')) {
        // Попытка извлечь тип из сообщения
        const vulnMatch = log.message.match(/(?:vulnerability|уязвимость)[\s:]+([a-z\s]+)/i);
        if (vulnMatch && !seen.has(vulnMatch[1])) {
          vulnerabilities.push({
            type: vulnMatch[1],
            severity: log.level === 'error' ? 'high' : 'medium',
            title: `Уязвимость: ${vulnMatch[1]}`,
          });
          seen.add(vulnMatch[1]);
        }
      }
    }
  }

  return vulnerabilities;
}



