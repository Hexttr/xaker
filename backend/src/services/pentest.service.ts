import { v4 as uuidv4 } from 'uuid';
import { Pentest, PentestConfig, PentestLog } from '../types/pentest';
import { join } from 'path';
import { existsSync, mkdirSync, writeFileSync, readFileSync, readdirSync } from 'fs';

class PentestService {
  private pentests: Map<string, Pentest> = new Map();
  private logs: Map<string, PentestLog[]> = new Map();
  private readonly DATA_DIR = join(process.cwd(), 'pentests-data');
  
  constructor() {
    // Создаем директорию для данных, если её нет
    if (!existsSync(this.DATA_DIR)) {
      mkdirSync(this.DATA_DIR, { recursive: true });
    }
    // Загружаем сохраненные пентесты при старте
    this.loadPentests();
  }

  createPentest(name: string, config: PentestConfig): Pentest {
    console.log(`[PentestService] createPentest() вызван: name="${name}", targetUrl="${config.targetUrl}"`);
    try {
      const pentest: Pentest = {
        id: uuidv4(),
        name,
        targetUrl: config.targetUrl,
        status: 'pending',
        config,
        createdAt: new Date().toISOString(),
      };

      this.pentests.set(pentest.id, pentest);
      this.logs.set(pentest.id, []);

      // Сохраняем на диск
      this.savePentest(pentest);

      this.addLog(pentest.id, 'info', `Пентест "${name}" создан`);
      console.log(`[PentestService] Пентест создан успешно: ${pentest.id}`);
      return pentest;
    } catch (error: any) {
      console.error(`[PentestService] Ошибка при создании пентеста:`, error);
      console.error(`[PentestService] Stack:`, error.stack);
      throw error;
    }
  }

  getPentest(id: string): Pentest | undefined {
    return this.pentests.get(id);
  }

  getAllPentests(): Pentest[] {
    console.log(`[PentestService] getAllPentests() вызван, всего пентестов: ${this.pentests.size}`);
    const result = Array.from(this.pentests.values()).sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
    console.log(`[PentestService] Возвращаю ${result.length} пентестов`);
    return result;
  }

  updatePentestStatus(id: string, status: Pentest['status']): boolean {
    const pentest = this.pentests.get(id);
    if (!pentest) return false;

    pentest.status = status;
    
    if (status === 'running' && !pentest.startedAt) {
      pentest.startedAt = new Date().toISOString();
      this.addLog(id, 'info', 'Пентест запущен');
    } else if (status === 'completed' || status === 'failed' || status === 'stopped') {
      pentest.completedAt = new Date().toISOString();
      this.addLog(id, status === 'completed' ? 'success' : 'info', `Пентест ${status === 'completed' ? 'завершен' : status === 'failed' ? 'завершился с ошибкой' : 'остановлен'}`);
    }

    // Сохраняем изменения на диск
    this.savePentest(pentest);

    return true;
  }

  deletePentest(id: string): boolean {
    const deleted = this.pentests.delete(id);
    this.logs.delete(id);
    
    // Удаляем файл с диска
    const filePath = join(this.DATA_DIR, `${id}.json`);
    if (existsSync(filePath)) {
      try {
        const fs = require('fs');
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error(`[PentestService] Ошибка при удалении файла ${filePath}:`, error);
      }
    }
    
    return deleted;
  }

  addLog(pentestId: string, level: PentestLog['level'], message: string): void {
    const log: PentestLog = {
      id: uuidv4(),
      pentestId,
      level,
      message,
      timestamp: new Date().toISOString(),
    };

    const pentestLogs = this.logs.get(pentestId) || [];
    pentestLogs.push(log);
    this.logs.set(pentestId, pentestLogs);
    
    // Сохраняем логи на диск
    this.saveLogs(pentestId);
  }

  getLogs(pentestId: string): PentestLog[] {
    return this.logs.get(pentestId) || [];
  }

  /**
   * Сохранить пентест на диск
   */
  private savePentest(pentest: Pentest): void {
    try {
      const filePath = join(this.DATA_DIR, `${pentest.id}.json`);
      const data = {
        pentest,
        logs: this.logs.get(pentest.id) || [],
      };
      writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');
    } catch (error) {
      console.error(`[PentestService] Ошибка при сохранении пентеста ${pentest.id}:`, error);
    }
  }

  /**
   * Сохранить логи на диск
   */
  private saveLogs(pentestId: string): void {
    const pentest = this.pentests.get(pentestId);
    if (pentest) {
      this.savePentest(pentest);
    }
  }

  /**
   * Загрузить все пентесты с диска
   */
  private loadPentests(): void {
    try {
      if (!existsSync(this.DATA_DIR)) {
        return;
      }

      const files = readdirSync(this.DATA_DIR).filter(file => file.endsWith('.json'));
      
      for (const file of files) {
        try {
          const filePath = join(this.DATA_DIR, file);
          const content = readFileSync(filePath, 'utf-8');
          const data = JSON.parse(content);
          
          if (data.pentest) {
            this.pentests.set(data.pentest.id, data.pentest);
            if (data.logs && Array.isArray(data.logs)) {
              this.logs.set(data.pentest.id, data.logs);
            }
          }
        } catch (error) {
          console.error(`[PentestService] Ошибка при загрузке файла ${file}:`, error);
        }
      }
      
      console.log(`[PentestService] Загружено ${this.pentests.size} пентестов с диска`);
    } catch (error) {
      console.error(`[PentestService] Ошибка при загрузке пентестов:`, error);
    }
  }
}

export const pentestService = new PentestService();

