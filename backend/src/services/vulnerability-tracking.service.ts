import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { pentestService } from './pentest.service';
import { vulnerabilityExtractorService } from './vulnerability-extractor.service';
import { vulnerabilityExtractorCacheService } from './vulnerability-extractor-cache.service';
import {
  VulnerabilityTracking,
  VulnerabilityFingerprint,
  VulnerabilityComparison,
  VulnerabilityStatus,
  PentestGroup,
  ProgressTimeline
} from '../types/vulnerability-tracking';
import { Pentest } from '../types/pentest';

/**
 * Сервис для отслеживания динамики уязвимостей между пентестами
 */
class VulnerabilityTrackingService {
  private readonly TRACKING_DIR = join(process.cwd(), 'pentests-tracking');

  constructor() {
    if (!existsSync(this.TRACKING_DIR)) {
      mkdirSync(this.TRACKING_DIR, { recursive: true });
    }
  }

  /**
   * Нормализовать URL для группировки
   */
  normalizeUrl(url: string): string {
    try {
      const urlObj = new URL(url);
      let normalized = urlObj.hostname.toLowerCase();
      
      // Убираем www
      if (normalized.startsWith('www.')) {
        normalized = normalized.substring(4);
      }
      
      return normalized;
    } catch {
      // Если не валидный URL, просто приводим к lowercase
      return url.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
    }
  }

  /**
   * Получить или создать группу пентестов для цели
   */
  getPentestGroup(targetUrl: string): PentestGroup | null {
    const normalizedUrl = this.normalizeUrl(targetUrl);
    const allPentests = pentestService.getAllPentests();
    
    // Фильтруем пентесты по нормализованному URL
    const groupPentests = allPentests
      .filter(p => this.normalizeUrl(p.targetUrl) === normalizedUrl)
      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());

    if (groupPentests.length === 0) {
      return null;
    }

    // Загружаем историю уязвимостей
    const vulnerabilityHistory = this.loadVulnerabilityHistory(normalizedUrl, groupPentests);

    return {
      normalizedUrl,
      targetUrl: groupPentests[0].targetUrl,
      pentests: groupPentests.map(p => ({
        id: p.id,
        name: p.name,
        targetUrl: p.targetUrl,
        createdAt: p.createdAt,
        completedAt: p.completedAt,
        status: p.status
      })) as any,
      latestPentest: groupPentests.length > 0 ? {
        id: groupPentests[groupPentests.length - 1].id,
        date: groupPentests[groupPentests.length - 1].completedAt || groupPentests[groupPentests.length - 1].createdAt
      } : undefined,
      firstPentest: groupPentests.length > 0 ? {
        id: groupPentests[0].id,
        date: groupPentests[0].createdAt
      } : undefined,
      vulnerabilityHistory,
      metrics: this.calculateGroupMetrics(vulnerabilityHistory, groupPentests)
    };
  }

  /**
   * Сравнить два пентеста
   */
  comparePentests(pentestId1: string, pentestId2: string): VulnerabilityComparison | null {
    const pentest1 = pentestService.getPentest(pentestId1);
    const pentest2 = pentestService.getPentest(pentestId2);

    if (!pentest1 || !pentest2) {
      return null;
    }

    // Извлекаем уязвимости (с кешированием)
    const vulns1 = vulnerabilityExtractorCacheService.getVulnerabilities(pentestId1);
    const vulns2 = vulnerabilityExtractorCacheService.getVulnerabilities(pentestId2);

    // Создаем мапы для быстрого поиска
    const map1 = this.createVulnerabilityMap(vulns1, pentestId1, pentest1);
    const map2 = this.createVulnerabilityMap(vulns2, pentestId2, pentest2);

    const comparison: VulnerabilityComparison = {
      fixed: [],
      remaining: [],
      new: [],
      partiallyFixed: [],
      worsened: [],
      regressed: [],
      metrics: {
        totalFixed: 0,
        totalRemaining: 0,
        totalNew: 0,
        fixRate: 0,
        improvementRate: 0
      }
    };

    // Проверяем уязвимости из первого пентеста
    for (const [key, tracking1] of map1.entries()) {
      const tracking2 = map2.get(key);

      if (!tracking2) {
        // Не найдена во втором = исправлена
        comparison.fixed.push(tracking1);
      } else {
        // Найдена во втором - проверяем изменения
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        const prevSeverity = severityOrder[tracking1.metrics.currentSeverity];
        const currSeverity = severityOrder[tracking2.metrics.currentSeverity];

        if (currSeverity < prevSeverity) {
          // Severity снизилась = частично исправлена
          comparison.partiallyFixed.push({
            previous: tracking1,
            current: tracking2
          });
        } else if (currSeverity > prevSeverity) {
          // Severity повысилась = ухудшилась
          comparison.worsened.push({
            previous: tracking1,
            current: tracking2
          });
        } else {
          // Severity не изменилась = осталась
          comparison.remaining.push(tracking2);
        }
      }
    }

    // Проверяем новые уязвимости во втором пентесте
    for (const [key, tracking2] of map2.entries()) {
      if (!map1.has(key)) {
        // Не было в первом = новая
        comparison.new.push(tracking2);
      }
    }

    // Проверяем регрессии (была исправлена, но появилась снова)
    // Для этого нужно проверить историю до первого пентеста
    const group = this.getPentestGroup(pentest1.targetUrl);
    if (group) {
      const allHistory = this.loadVulnerabilityHistory(group.normalizedUrl, group.pentests);
      for (const tracking of allHistory) {
        const wasFixed = tracking.metrics.fixedDate && 
          new Date(tracking.metrics.fixedDate) < new Date(pentest1.createdAt);
        const foundIn2 = map2.has(tracking.normalizedId);
        
        if (wasFixed && foundIn2) {
          comparison.regressed.push(tracking);
        }
      }
    }

    // Рассчитываем метрики
    comparison.metrics = {
      totalFixed: comparison.fixed.length,
      totalRemaining: comparison.remaining.length,
      totalNew: comparison.new.length,
      fixRate: vulns1.length > 0 ? (comparison.fixed.length / vulns1.length) * 100 : 0,
      improvementRate: this.calculateImprovementRate(vulns1, vulns2)
    };

    return comparison;
  }

  /**
   * Создать мапу уязвимостей для быстрого поиска
   */
  private createVulnerabilityMap(
    vulnerabilities: VulnerabilityFingerprint[],
    pentestId: string,
    pentest: Pentest
  ): Map<string, VulnerabilityTracking> {
    const map = new Map<string, VulnerabilityTracking>();

    for (const vuln of vulnerabilities) {
      const normalizedId = this.getNormalizedId(vuln);
      
      const tracking: VulnerabilityTracking = {
        normalizedId,
        fingerprint: vuln,
        history: [{
          pentestId,
          pentestName: pentest.name,
          pentestDate: pentest.completedAt || pentest.createdAt,
          status: 'new' as VulnerabilityStatus,
          severity: vuln.severity,
          found: true,
          details: {
            description: vuln.title,
            location: vuln.location
          }
        }],
        metrics: {
          firstFound: pentest.completedAt || pentest.createdAt,
          lastFound: pentest.completedAt || pentest.createdAt,
          timesFound: 1,
          timesFixed: 0,
          currentStatus: 'new',
          currentSeverity: vuln.severity
        }
      };

      map.set(normalizedId, tracking);
    }

    return map;
  }

  /**
   * Получить нормализованный ID для группировки уязвимостей
   */
  private getNormalizedId(vuln: VulnerabilityFingerprint): string {
    // Используем hash если есть, иначе создаем из type + location + title
    if (vuln.hash) {
      return vuln.hash;
    }
    
    const crypto = require('crypto');
    const str = `${vuln.type}|${vuln.location}|${vuln.title}`.toLowerCase().trim();
    return crypto.createHash('md5').update(str).digest('hex');
  }

  /**
   * Загрузить историю уязвимостей для группы пентестов
   */
  private loadVulnerabilityHistory(
    normalizedUrl: string,
    pentests: Array<{ id: string; name: string; targetUrl: string; createdAt: string; completedAt?: string; status: string }>
  ): VulnerabilityTracking[] {
    const historyFile = join(this.TRACKING_DIR, `${normalizedUrl.replace(/[^a-z0-9]/gi, '_')}.json`);

    // Если файл существует, загружаем
    let existingHistory: Map<string, VulnerabilityTracking> = new Map();
    if (existsSync(historyFile)) {
      try {
        const content = readFileSync(historyFile, 'utf-8');
        const data = JSON.parse(content);
        if (Array.isArray(data)) {
          for (const item of data) {
            existingHistory.set(item.normalizedId, item);
          }
        }
      } catch (error) {
        console.error(`Error loading history from ${historyFile}:`, error);
      }
    }

    // Обновляем историю на основе всех пентестов
    for (const pentest of pentests) {
      const vulns = vulnerabilityExtractorCacheService.getVulnerabilities(pentest.id);
      
      for (const vuln of vulns) {
        const normalizedId = this.getNormalizedId(vuln);
        let tracking = existingHistory.get(normalizedId);

        if (!tracking) {
          // Новая уязвимость
          tracking = {
            normalizedId,
            fingerprint: vuln,
            history: [],
            metrics: {
              firstFound: pentest.completedAt || pentest.createdAt,
              lastFound: pentest.completedAt || pentest.createdAt,
              timesFound: 1,
              timesFixed: 0,
              currentStatus: 'new',
              currentSeverity: vuln.severity
            }
          };
        } else {
          // Обновляем существующую
          tracking.metrics.timesFound++;
          tracking.metrics.lastFound = pentest.completedAt || pentest.createdAt;
          tracking.metrics.currentSeverity = vuln.severity;
          
          // Проверяем, была ли исправлена ранее
          const wasFixed = tracking.metrics.fixedDate && 
            new Date(tracking.metrics.fixedDate) < new Date(pentest.createdAt);
          
          if (wasFixed) {
            tracking.metrics.currentStatus = 'regressed';
          } else {
            tracking.metrics.currentStatus = 'remaining';
          }
        }

        // Добавляем запись в историю
        const historyEntry = {
          pentestId: pentest.id,
          pentestName: pentest.name,
          pentestDate: pentest.completedAt || pentest.createdAt,
          status: tracking.metrics.currentStatus,
          severity: vuln.severity,
          found: true,
          details: {
            description: vuln.title,
            location: vuln.location
          }
        };

        // Проверяем, нет ли уже записи для этого пентеста
        const existingEntryIndex = tracking.history.findIndex(h => h.pentestId === pentest.id);
        if (existingEntryIndex >= 0) {
          tracking.history[existingEntryIndex] = historyEntry;
        } else {
          tracking.history.push(historyEntry);
        }

        existingHistory.set(normalizedId, tracking);
      }

      // Отмечаем уязвимости как исправленные, если их нет в текущем пентесте
      for (const [key, tracking] of existingHistory.entries()) {
        const foundInThisPentest = vulns.some(v => this.getNormalizedId(v) === key);
        
        if (!foundInThisPentest) {
          // Не найдена в этом пентесте - возможно исправлена
          const lastFound = tracking.metrics.lastFound;
          const thisPentestDate = pentest.completedAt || pentest.createdAt;
          
          if (lastFound && new Date(lastFound) < new Date(thisPentestDate)) {
            // Последний раз найдена раньше этого пентеста = исправлена
            if (!tracking.metrics.fixedDate) {
              tracking.metrics.fixedDate = thisPentestDate;
              tracking.metrics.timesFixed++;
            }
            tracking.metrics.currentStatus = 'fixed';
          }
        }
      }
    }

    // Сохраняем обновленную историю
    this.saveVulnerabilityHistory(normalizedUrl, Array.from(existingHistory.values()));

    return Array.from(existingHistory.values());
  }

  /**
   * Сохранить историю уязвимостей
   */
  private saveVulnerabilityHistory(normalizedUrl: string, history: VulnerabilityTracking[]): void {
    const historyFile = join(this.TRACKING_DIR, `${normalizedUrl.replace(/[^a-z0-9]/gi, '_')}.json`);
    writeFileSync(historyFile, JSON.stringify(history, null, 2), 'utf-8');
  }

  /**
   * Рассчитать метрики группы
   */
  private calculateGroupMetrics(
    history: VulnerabilityTracking[],
    pentests: Pentest[]
  ): PentestGroup['metrics'] {
    const fixed = history.filter(v => v.metrics.currentStatus === 'fixed').length;
    const remaining = history.filter(v => v.metrics.currentStatus === 'remaining').length;
    const newVulns = history.filter(v => v.metrics.currentStatus === 'new').length;
    const total = history.length;

    // Рассчитываем балл безопасности (0-10)
    let securityScore = 10;
    for (const vuln of history) {
      if (vuln.metrics.currentStatus !== 'fixed') {
        const severityPenalty = {
          critical: 2,
          high: 1.5,
          medium: 1,
          low: 0.5
        };
        securityScore -= severityPenalty[vuln.metrics.currentSeverity] || 0;
      }
    }
    securityScore = Math.max(0, Math.min(10, securityScore));

    // Процент улучшения
    const firstPentest = pentests[0];
    const lastPentest = pentests[pentests.length - 1];
    
    let improvementRate = 0;
    if (firstPentest && lastPentest && firstPentest.id !== lastPentest.id) {
      const firstVulns = vulnerabilityExtractorCacheService.getVulnerabilities(firstPentest.id);
      const lastVulns = vulnerabilityExtractorCacheService.getVulnerabilities(lastPentest.id);
      
      if (firstVulns.length > 0) {
        improvementRate = ((firstVulns.length - lastVulns.length) / firstVulns.length) * 100;
      }
    }

    return {
      totalVulnerabilities: total,
      fixedVulnerabilities: fixed,
      remainingVulnerabilities: remaining,
      newVulnerabilities: newVulns,
      securityScore: Math.round(securityScore * 10) / 10,
      improvementRate: Math.round(improvementRate * 10) / 10
    };
  }

  /**
   * Рассчитать процент улучшения
   */
  private calculateImprovementRate(
    vulns1: VulnerabilityFingerprint[],
    vulns2: VulnerabilityFingerprint[]
  ): number {
    if (vulns1.length === 0) return 0;
    
    const severityWeight = { critical: 4, high: 3, medium: 2, low: 1 };
    
    const score1 = vulns1.reduce((sum, v) => sum + (severityWeight[v.severity] || 0), 0);
    const score2 = vulns2.reduce((sum, v) => sum + (severityWeight[v.severity] || 0), 0);
    
    if (score1 === 0) return 0;
    
    return ((score1 - score2) / score1) * 100;
  }

  /**
   * Получить timeline прогресса
   */
  getProgressTimeline(targetUrl: string): ProgressTimeline[] {
    const group = this.getPentestGroup(targetUrl);
    if (!group) return [];

    const timeline: ProgressTimeline[] = [];

    for (const pentest of group.pentests) {
      if (pentest.status !== 'completed') continue;

      const vulns = vulnerabilityExtractorCacheService.getVulnerabilities(pentest.id);
      
      const bySeverity = {
        critical: vulns.filter(v => v.severity === 'critical').length,
        high: vulns.filter(v => v.severity === 'high').length,
        medium: vulns.filter(v => v.severity === 'medium').length,
        low: vulns.filter(v => v.severity === 'low').length
      };

      // Рассчитываем балл безопасности
      let securityScore = 10;
      for (const vuln of vulns) {
        const severityPenalty = {
          critical: 2,
          high: 1.5,
          medium: 1,
          low: 0.5
        };
        securityScore -= severityPenalty[vuln.severity] || 0;
      }
      securityScore = Math.max(0, Math.min(10, securityScore));

      timeline.push({
        date: pentest.completedAt || pentest.createdAt,
        pentestId: pentest.id,
        pentestName: pentest.name,
        vulnerabilityCount: vulns.length,
        bySeverity,
        securityScore: Math.round(securityScore * 10) / 10
      });
    }

    return timeline.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
  }
}

export const vulnerabilityTrackingService = new VulnerabilityTrackingService();

