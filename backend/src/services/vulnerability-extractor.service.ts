import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { VulnerabilityFingerprint } from '../types/vulnerability-tracking';

/**
 * Сервис для извлечения уязвимостей из файлов deliverables
 */
class VulnerabilityExtractorService {
  /**
   * Извлечь все уязвимости из пентеста
   */
  extractVulnerabilitiesFromPentest(pentestId: string): VulnerabilityFingerprint[] {
    const deliverablesDir = join(process.cwd(), 'pentests', pentestId, 'deliverables');
    
    if (!existsSync(deliverablesDir)) {
      return [];
    }

    const vulnerabilities: VulnerabilityFingerprint[] = [];

    // 1. Парсим comprehensive_security_assessment_report.md
    const comprehensiveReport = join(deliverablesDir, 'comprehensive_security_assessment_report.md');
    if (existsSync(comprehensiveReport)) {
      const vulns = this.extractFromComprehensiveReport(comprehensiveReport);
      vulnerabilities.push(...vulns);
    }

    // 2. Парсим auth_exploitation_evidence.md
    const authEvidence = join(deliverablesDir, 'auth_exploitation_evidence.md');
    if (existsSync(authEvidence)) {
      const vulns = this.extractFromExploitationEvidence(authEvidence, 'Authentication');
      vulnerabilities.push(...vulns);
    }

    // 3. Парсим authz_exploitation_evidence.md
    const authzEvidence = join(deliverablesDir, 'authz_exploitation_evidence.md');
    if (existsSync(authzEvidence)) {
      const vulns = this.extractFromExploitationEvidence(authzEvidence, 'Authorization');
      vulnerabilities.push(...vulns);
    }

    // 4. Парсим JSON файлы exploitation_queue
    const authQueue = join(deliverablesDir, 'auth_exploitation_queue.json');
    if (existsSync(authQueue)) {
      const vulns = this.extractFromExploitationQueue(authQueue, 'Authentication');
      vulnerabilities.push(...vulns);
    }

    const authzQueue = join(deliverablesDir, 'authz_exploitation_queue.json');
    if (existsSync(authzQueue)) {
      const vulns = this.extractFromExploitationQueue(authzQueue, 'Authorization');
      vulnerabilities.push(...vulns);
    }

    // Удаляем дубликаты по fingerprint
    return this.deduplicateVulnerabilities(vulnerabilities);
  }

  /**
   * Извлечь уязвимости из comprehensive_security_assessment_report.md
   */
  private extractFromComprehensiveReport(filePath: string): VulnerabilityFingerprint[] {
    const content = readFileSync(filePath, 'utf-8');
    const vulnerabilities: VulnerabilityFingerprint[] = [];

    // Паттерн: "AUTH-VULN-01: Title" или "### AUTH-VULN-01: Title"
    // Более точный паттерн для захвата полного названия
    const vulnPattern = /(?:###\s+)?(AUTH-VULN-\d+|AUTHZ-VULN-\d+|XSS-VULN-\d+|SQL-VULN-\d+|SSRF-VULN-\d+|INJECTION-VULN-\d+):\s*([^\n\(]+?)(?:\s*\(([A-Z]+)\))?/gi;
    
    // Паттерн для таблиц уязвимостей
    const tablePattern = /\|.*?(AUTH-VULN-\d+|AUTHZ-VULN-\d+).*?\|.*?(CRITICAL|HIGH|MEDIUM|LOW).*?\|/gi;

    let match;
    
    // Извлекаем из заголовков и текста
    while ((match = vulnPattern.exec(content)) !== null) {
      const id = match[1];
      let title = match[2].trim();
      // Очищаем title от лишних символов
      title = title.replace(/[^\w\s\-:]/g, '').trim();
      // Если title слишком короткий, ищем полное название дальше
      if (title.length < 5) {
        const afterMatch = content.substring(match.index + match[0].length, match.index + match[0].length + 200);
        const titleMatch = afterMatch.match(/^[^\n]+/);
        if (titleMatch && titleMatch[0].trim().length > title.length) {
          title = titleMatch[0].trim().substring(0, 100);
        }
      }
      
      const severity = this.normalizeSeverity(match[3] || this.extractSeverityFromContext(content, id));
      
      // Ищем location в тексте после заголовка
      const location = this.extractLocation(content, id, match.index);
      const type = this.extractTypeFromId(id);

      // Пропускаем если title слишком короткий (вероятно ошибка парсинга)
      if (title.length < 3) continue;
      
      // Если title все еще короткий, пытаемся найти в Summary
      if (title.length < 10) {
        const section = content.substring(match.index, match.index + 1000);
        const summaryMatch = section.match(/\*\*Summary:\*\*\s*-?\s*([^\n]+)/i);
        if (summaryMatch) {
          title = summaryMatch[1].trim().substring(0, 150);
        }
      }

      vulnerabilities.push({
        id,
        type,
        location: location || 'Unknown',
        title,
        severity: severity as 'critical' | 'high' | 'medium' | 'low',
        hash: this.generateHash(type, location, title)
      });
    }

    // Извлекаем из таблиц
    while ((match = tablePattern.exec(content)) !== null) {
      const id = match[1];
      const severity = this.normalizeSeverity(match[2]);
      
      // Ищем детали этой уязвимости в тексте
      const details = this.findVulnerabilityDetails(content, id);
      
      if (details) {
        vulnerabilities.push({
          id,
          type: this.extractTypeFromId(id),
          location: details.location || 'Unknown',
          title: details.title || id,
          severity: severity as 'critical' | 'high' | 'medium' | 'low',
          hash: this.generateHash(this.extractTypeFromId(id), details.location || 'Unknown', details.title || id)
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Извлечь уязвимости из exploitation_evidence.md
   */
  private extractFromExploitationEvidence(filePath: string, type: string): VulnerabilityFingerprint[] {
    const content = readFileSync(filePath, 'utf-8');
    const vulnerabilities: VulnerabilityFingerprint[] = [];

    // Паттерн: "### AUTH-VULN-01: Title"
    const pattern = /###\s+(AUTH-VULN-\d+|AUTHZ-VULN-\d+):\s*([^\n]+?)(?:\s*\(([A-Z]+)\))?/gi;
    
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const id = match[1];
      let title = match[2].trim();
      // Очищаем title от лишних символов, но сохраняем пробелы
      title = title.replace(/[^\w\s\-:()]/g, '').trim();
      
      // Если title слишком короткий, ищем в Summary секции
      if (title.length < 5) {
        const section = content.substring(match.index, match.index + 500);
        const summaryMatch = section.match(/\*\*Summary:\*\*\s*-?\s*([^\n]+)/i);
        if (summaryMatch) {
          title = summaryMatch[1].trim().substring(0, 150);
        }
      }
      
      const severity = this.normalizeSeverity(match[3] || this.extractSeverityFromContext(content, id));
      
      // Ищем "Vulnerable location:" в тексте
      const locationMatch = content.substring(match.index).match(/Vulnerable location[:\s]+(.+?)(?:\n|$)/i);
      const location = locationMatch ? locationMatch[1].trim() : 'Unknown';

      // Пропускаем если title слишком короткий
      if (title.length < 3) continue;

      vulnerabilities.push({
        id,
        type,
        location,
        title,
        severity: severity as 'critical' | 'high' | 'medium' | 'low',
        hash: this.generateHash(type, location, title)
      });
    }

    return vulnerabilities;
  }

  /**
   * Извлечь уязвимости из exploitation_queue.json
   */
  private extractFromExploitationQueue(filePath: string, type: string): VulnerabilityFingerprint[] {
    try {
      const content = readFileSync(filePath, 'utf-8');
      const data = JSON.parse(content);
      const vulnerabilities: VulnerabilityFingerprint[] = [];

      if (Array.isArray(data)) {
        for (const item of data) {
          if (item.id && item.title) {
            vulnerabilities.push({
              id: item.id,
              type,
              location: item.location || item.endpoint || 'Unknown',
              title: item.title,
              severity: this.normalizeSeverity(item.severity || item.criticality) as 'critical' | 'high' | 'medium' | 'low',
              hash: this.generateHash(type, item.location || 'Unknown', item.title)
            });
          }
        }
      }

      return vulnerabilities;
    } catch (error) {
      console.error(`Error parsing ${filePath}:`, error);
      return [];
    }
  }

  /**
   * Извлечь тип из ID уязвимости
   */
  private extractTypeFromId(id: string): string {
    if (id.startsWith('AUTH-VULN-')) return 'Authentication';
    if (id.startsWith('AUTHZ-VULN-')) return 'Authorization';
    if (id.startsWith('XSS-VULN-')) return 'XSS';
    if (id.startsWith('SQL-VULN-')) return 'SQL Injection';
    if (id.startsWith('SSRF-VULN-')) return 'SSRF';
    if (id.startsWith('INJECTION-VULN-')) return 'Injection';
    return 'Unknown';
  }

  /**
   * Извлечь location из контекста
   */
  private extractLocation(content: string, vulnId: string, startIndex: number): string {
    // Ищем в тексте после упоминания уязвимости
    const section = content.substring(startIndex, startIndex + 2000);
    
    // Паттерны для location
    const patterns = [
      /location[:\s]+(.+?)(?:\n|$)/i,
      /endpoint[:\s]+(.+?)(?:\n|$)/i,
      /URL[:\s]+(.+?)(?:\n|$)/i,
      /(?:POST|GET|PUT|DELETE)\s+(.+?)(?:\n|$)/i,
      /https?:\/\/[^\s]+/i
    ];

    for (const pattern of patterns) {
      const match = section.match(pattern);
      if (match) {
        let location = match[1] || match[0];
        location = location.trim();
        // Очищаем от лишних символов
        location = location.replace(/[`'"]/g, '').trim();
        if (location && location.length < 200) {
          return location;
        }
      }
    }

    return 'Unknown';
  }

  /**
   * Найти детали уязвимости в тексте
   */
  private findVulnerabilityDetails(content: string, vulnId: string): { title: string; location: string } | null {
    const pattern = new RegExp(`${vulnId}[^\\n]*\\n([\\s\\S]{0,500})`, 'i');
    const match = content.match(pattern);
    
    if (match) {
      const section = match[1];
      const titleMatch = section.match(/(?:Title|Name|Vulnerability)[:\s]+(.+?)(?:\n|$)/i);
      const locationMatch = section.match(/(?:Location|Endpoint|URL)[:\s]+(.+?)(?:\n|$)/i);
      
      return {
        title: titleMatch ? titleMatch[1].trim() : vulnId,
        location: locationMatch ? locationMatch[1].trim() : 'Unknown'
      };
    }

    return null;
  }

  /**
   * Извлечь severity из контекста
   */
  private extractSeverityFromContext(content: string, vulnId: string): string {
    const pattern = new RegExp(`${vulnId}[^\\n]*\\n([\\s\\S]{0,300})`, 'i');
    const match = content.match(pattern);
    
    if (match) {
      const section = match[1];
      const severityMatch = section.match(/(?:Severity|Criticality)[:\s]+(CRITICAL|HIGH|MEDIUM|LOW)/i);
      if (severityMatch) {
        return severityMatch[1];
      }
    }

    return 'MEDIUM';
  }

  /**
   * Нормализовать severity
   */
  private normalizeSeverity(severity?: string): 'critical' | 'high' | 'medium' | 'low' {
    if (!severity) return 'medium';
    
    const normalized = severity.toUpperCase();
    if (normalized.includes('CRITICAL')) return 'critical';
    if (normalized.includes('HIGH')) return 'high';
    if (normalized.includes('MEDIUM')) return 'medium';
    if (normalized.includes('LOW')) return 'low';
    
    return 'medium';
  }

  /**
   * Генерировать хеш для сравнения
   */
  private generateHash(type: string, location: string, title: string): string {
    const crypto = require('crypto');
    const str = `${type}|${location}|${title}`.toLowerCase().trim();
    return crypto.createHash('md5').update(str).digest('hex');
  }

  /**
   * Удалить дубликаты уязвимостей
   */
  private deduplicateVulnerabilities(vulns: VulnerabilityFingerprint[]): VulnerabilityFingerprint[] {
    const seen = new Map<string, VulnerabilityFingerprint>();
    
    for (const vuln of vulns) {
      const key = vuln.hash || `${vuln.type}|${vuln.location}|${vuln.title}`;
      
      if (!seen.has(key)) {
        seen.set(key, vuln);
      } else {
        // Если уже есть, берем более детальную версию
        const existing = seen.get(key)!;
        if (vuln.location !== 'Unknown' && existing.location === 'Unknown') {
          seen.set(key, vuln);
        }
      }
    }
    
    return Array.from(seen.values());
  }
}

export const vulnerabilityExtractorService = new VulnerabilityExtractorService();

